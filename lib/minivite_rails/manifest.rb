# frozen_string_literal: true

# Modified from vite_ruby's source code
# https://github.com/ElMassimo/vite_ruby/blob/main/vite_ruby/lib/vite_ruby/manifest.rb

require 'json'
require 'active_support/core_ext/object/blank'
require 'rails'

module MiniviteRails
  # Class to load and parse the manifest.json file generated by Vite.
  class Manifest
    class FileNotFoundError < StandardError; end
    class MissingEntryError < StandardError; end

    attr_reader :config, :manifest_path

    def initialize(config)
      update_config(config)
    end

    def update_config(config)
      @config = config
      @manifest_path = config.manifest_path || File.join(config.public_asset_dir, '.vite', 'manifest.json')
      @data = nil
    end

    def data
      return load_manifest unless config.cache

      @data ||= load_manifest
    end

    def path_for(name, **options)
      lookup!(name, **options).fetch('file')
    end

    def public_path_for(name)
      return prefix_vite_asset(name) if dev_server_available?

      File.join(config.public_base_path, name)
    end

    def vite_client_src
      prefix_vite_asset('@vite/client') if dev_server_available?
    end

    def resolve_entries(*names, **options) # rubocop:disable Metrics/AbcSize,Metrics/CyclomaticComplexity
      entries = names.map { |name| lookup!(name, **options) }
      script_paths = entries.map { |entry| entry.fetch('file') }

      imports = dev_server_available? ? [] : entries.flat_map { |entry| entry['imports'] }.compact.uniq
      {
        scripts: script_paths,
        imports: imports.map { |entry| entry.fetch('file') }.uniq,
        stylesheets: dev_server_available? ? [] : (entries + imports).flat_map { |entry| entry['css'] }.compact.uniq
      }
    end

    # Public: The content of the preamble needed by the React Refresh plugin.
    def react_refresh_preamble
      return unless dev_server_running?

      <<~REACT_REFRESH
        <script type="module">
          #{react_preamble_code}
        </script>
      REACT_REFRESH
    end

    # Public: Source script for the React Refresh plugin.
    def react_preamble_code
      return unless dev_server_available?

      <<~REACT_PREAMBLE_CODE
        import RefreshRuntime from '#{prefix_vite_asset('@react-refresh')}'
        RefreshRuntime.injectIntoGlobalHook(window)
        window.$RefreshReg$ = () => {}
        window.$RefreshSig$ = () => (type) => type
        window.__vite_plugin_react_preamble_installed__ = true
      REACT_PREAMBLE_CODE
    end

    protected

    def dev_server_available?
      !Rails.env.production? && config.vite_dev_server.present?
    end

    def load_manifest
      u = URI.parse(manifest_path)
      data = nil
      if u.scheme == 'file' || u.path == manifest_path # file path
        raise(FileNotFoundError, "#{manifest_path}: no such manifest found") unless File.exist?(manifest_path)

        data = File.read(manifest_path)
      else
        # http url
        data = u.read
      end
      JSON.parse(data).tap(&method(:resolve_references))
    end

    def prefix_vite_asset(path)
      root_path = dev_server_available? ? config.vite_dev_server : '/'
      File.join(root_path, config.public_base_path, path)
    end

    # Internal: Resolves the paths that reference a manifest entry.
    def resolve_references(manifest)
      manifest.each_value do |entry|
        entry['file'] = prefix_vite_asset(entry['file'])
        %w[css assets].each do |key|
          entry[key] = entry[key].map { |path| prefix_vite_asset(path) } if entry[key]
        end
        entry['imports']&.map! { |name| manifest.fetch(name) }
      end
    end

    def lookup!(name, **options)
      lookup(name, **options) || missing_entry_error(name, **options)
    end

    # Internal: Computes the path for a given Vite asset using manifest.json.
    #
    # Returns a relative path, or nil if the asset is not found.
    #
    # Example:
    #   manifest.lookup('calendar.js')
    #   => { "file" => "/vite/assets/calendar-1016838bab065ae1e122.js", "imports" => [] }
    def lookup(name, **options)
      find_manifest_entry(resolve_entry_name(name, **options))
    end

    def find_manifest_entry(name)
      # If dev server is available, we don't need to get manifest entry from the manifest
      dev_server_available? ? { 'file' => prefix_vite_asset(name) } : data[name]
    end

    def resolve_entry_name(name, type: nil)
      name = with_file_extension(name.to_s, type)
      if name =~ %r{\A(\.|~|/).+}
        raise ArgumentError, "Asset names must be direct path from the project root. Found: #{name}"
      end

      name
    end

    # Internal: Adds a file extension to the file name, unless it already has one.
    def with_file_extension(name, entry_type)
      return name unless File.extname(name).empty?

      "#{name}.#{extension_for_type(entry_type)}"
    end

    # Internal: Allows to receive :javascript and :stylesheet as :type in helpers.
    def extension_for_type(entry_type)
      case entry_type
      when :javascript then 'js'
      when :stylesheet then 'css'
      when :typescript then 'ts'
      else entry_type
      end
    end

    # Internal: Raises a detailed message when an entry is missing in the manifest.
    def missing_entry_error(name, **_options)
      raise MissingEntryError, <<~MSG
        Can not find #{name} in #{manifest_path}.
        Your manifest contains:
        #{JSON.pretty_generate(data)}
      MSG
    end
  end
end
